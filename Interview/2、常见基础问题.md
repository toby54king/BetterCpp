# C++面试常见基础问题汇总

## 一、写一个宏,取较小值
#define MIN(A,B)  ((A)<=(B)?(A):(B))

## 二、#define和typedef的区别
1、用法不同：typedef 用来定义一种数据类型的别名，增强程序的可读性；define 主要用来定义常量，以及书写复杂使用频繁的宏。
2、执行时间不同：typedef 是编译过程的一部分，有类型检查的功能；define 是宏定义，是预编译的部分，其发生在编译之前，只是简单的进行字符串的替换，不进行类型检查。
3、作用域不同：typedef 有作用域限定；define 不受作用域约束，只要是在 define 声明后的引用都是正确的。
4、对指针的操作不同：typedef 和 define 定义的指针时有很大的区别。

```
#define PINT int*
typedef int* Pint;
int a = 3;
int b = 5;
const Pint p1 = &a;  //相当于int* const p1，p1不可以更改但其指向的内容可改
*p1 = 1;  //指向的内容被修改，正确
p1 = &b;  //错误
const PINT p2 = &a;  //相当于const int *p2，p2可以被修改但其指向的内容不可修改
p2 = &b;  //正确
*p2 = 1;  //错误
```

## 三、sizeof求类的大小
空类class A {}；
加构造函数,析构函数；
加一个static int成员；
把析构函数标记为虚函数；
sizeof(A)是多少?

注意要点：
1、C++中规定只要是一个独立的对象内存大小必须是非0的，所以空类大小是1。
2、静态数据程序不计算在类对象大小中，为所有的类对象所共有，定义在内存全局区。
3、类大小的计算遵循结构体的对齐原则。
4、类的大小与普通数据成员有关，与成员函数和静态成员无关。即普通成员函数，静态成员函数，静态数据成员，静态常量数据成员均对类的大小无影响。
5、虚函数对类的大小有影响，是因为虚函数表指针带来的影响。
6、虚继承对类的大小有影响，是因为虚基表指针带来的影响。

## 四、sizeof和strlen的区别
主要区别：
1、sizeof() 是一个运算符，而 strlen() 是一个函数。
2、sizeof() 计算的是变量或类型所占用的内存字节数，而 strlen() 计算的是字符串中字符的个数。
3、sizeof() 可以用于任何类型的数据，而 strlen() 只能用于以空字符 '\0' 结尾的字符串。
4、sizeof() 计算字符串的长度，包含末尾的 '\0'，strlen() 计算字符串的长度，不包含字符串末尾的 '\0'。
5、sizeof() 是一个运算符而不是函数，用于计算一个类型或变量所占用的内存字节数；可以用它来获取任何类型的数据的字节数，包括基本数据类型、数组、结构体、共用体等等。
```
char aa[10];strlen(aa);          //结果是不定的   
sizeof(aa);      //结果是10
char aa[10]={‘\0’};strlen(aa);  //结果为0        
sizeof(aa);      //结果是10
char aa[]=”CPP”;strlen(aa);     //结果为3             
sizeof(aa);      //结果是4
char*aa=”0123456789”;   //字符串常量的情况
sizeof(aa);        //结果为4，指针的长度
sizeof(*aa);       //结果为1，第一个字符的空间
strlen(aa);         //结果为0，该字符串的长度

char aaa[]={"CPPCPP"};
int a,b;
fun(aaa,a,b);
void fun(char aaa[],int&a,int&b)
{
  a=strlen(aaa);
  b=sizeof(aaa);
}
//得到的a=6，b=4.在函数内部，虽然aaa转化成指针，但是strlen还是测试aaa开始直到’\0’为止的字符串的长度，而sizeof则是测指针的长度
```
## 五、字节对齐
1、意义：结构体以及类成员对齐，目的就是减少cpu读取的次数，提高效率。
2、结构体成员对齐的规则：
1）结构体大小等于结构体内最大成员大小的整数倍；
2）结构体内的成员的首地址相对于结构体首地址的偏移量，是其类型大小的整数倍，比如说double型成员相对于结构体的首地址的偏移量应该是8的整数倍；
3）为了满足规则1和规则2编译器会在结构体成员之后进行字节填充。
```
struct A{
  char a;
  double b;
  int c;
};
struct B{
  double a;
  char b;
  int c;
};
sizeof(A):24
sizeof(B):16
```
## 六、封装、继承、多态
1、封装
定义：封装就是将抽象的数据和行为相结合，形成一个有机的整体类，其中数据和函数都是类的成员，目的在于将对象的使用者和设计者分开，以提高软件的可维护性和可修改性。
特性：1) 结合性，即是将属性和方法结合；2）信息隐蔽性，利用接口机制隐蔽内部实现细节，只留下接口给外界调用，便于权限控制；3）实现代码重用。

2、继承
1）继承就是新类从已有类那里得到已有的特性，类的派生指的是从已有类产生新类的过程，原有的类成为基类或父类，产生的新类称为派生类或子类。
2）继承可以扩展已存在的代码，目的也是为了代码重用。
3）继承增加了类的耦合性。
4）继承是多态的前提。

3、多态
1）多态性可以简单地概括为“一个接口，多种方法”，类和继承的存在就是为了实现多态。
2）它是面向对象编程领域的核心概念，程序在运行时才决定调用的函数，比如函数重载、运算符重载、虚函数等都是为了多态而存在。
3）多态有两种形式的多态，一种是静态多态，一种是动态多态。
静态多态通过模板和重载实现；动态多态通过需函数实现。

## 七、指针和引用
1、指针：一个存放变量地址的变量，在逻辑上是独立的，它可以被改变，包括其所指向的地址的改变和其指向的地址中所存放的数据的改变。
2、引用是一个别名，它在逻辑上不是独立的，它的存在具有依附性，所以引用必须在一开始就被初始化，而且其引用的对象在其整个生命周期中是不能被改变的，自始至终只能依附于同一个变量。
3、指针和引用的区别：
1）引用必须被初始化，但是不分配存储空间；指针不声明时初始化，在初始化的时候需要分配存储空间。
2）引用初始化后不能被改变，指针可以改变所指的对象。
3）不存在指向空值的引用，但是存在指向空值的指针。

## 八、内联函数与宏函数、普通函数相比的优势
1、从类型安全检查上看，内联函数与普通函数都有类型安全检查，而宏函数没有类型安全检查，inline函数类型安全时才进行展开。
2、从代码量上看，宏函数在预处理阶段就进行了宏展开，因此生成的目标文件可能会很大；而inline函数则只在运行时才进行展开。
3、从效率上看，内联函数在运行时才展开，而普通函数在调用时，需要申请栈空间，保存调用语句的下一执行语句地址，参数压栈等操作，因此内联函数的效率更高。
4、内联函数可以访问类的成员变量，宏定义则不能。
5、在类中声明同时定义的成员函数，自动转化为内联函数。

## 九、数组和指针的区别
1、在C++中，数组名和指针之间，经常会交替使用这两个变量，可以把一个指针当成数组来使用，或者是把数组名赋值给指针，通过指针来访问数组成员变量。虽然数组名与指针很多场景是可以通用，但它们还是有区别的，数组名不等于指针。
2、数组名取地址得到的是数组名所指元素的地址，而对指针取地址得到的是指针变量自身的地址，数组名是常量指针，而指针是变量指针。
3、当对数组名使用sizeof时，得到的是数组元素的个数乘以元素类型的字节数，而对指针sizeof得到的是指针类型的字节数。


## 十、指针数组和数组指针的区别
1、指针数组：指针数组是”指针的数组”，该变量是一个数组；”指针”修饰这个数组，就是说该数组的所有元素都是指针类型。
2、数组指针：数组指针是”数组的指针”，该变量是一个指针；”数组”修饰这个指针，就是说该指针存放着一个数组的首地址，或者说该指针指向一个数组的首地址。
3、指针数组和数组指针是两种类型的变量。

## 十一、初始化列表
1、每个成员在成员初始化表中只能出现一次,初始化的顺序不是由名字在初始化表中的顺序决定,而是由成员在类中被声明的顺序决定的。
2、使用初始化表和在构造函数内使用数据成员的赋值之间区别：成员初始化表只提供该类数据成员的初始化,在构造函数体内对数据成员设置值是一个赋值操作。
3、对于被声明为内置类型的数据成员,用成员初始化表和在构造函数体内初始化是否等价：对于非类数据成员的初始化或赋值除了两个例外,两者在结果和性能上都是等价的。
两个例外是指任何类型的 const 和引用数据成,const 和引用数据成员也必须是在成员初 始化表中被初始化。



