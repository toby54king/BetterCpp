# C++面试常见基础问题汇总

## 一、写一个宏,取较小值
#define MIN(A,B)  ((A)<=(B)?(A):(B))

## 二、#define和typedef的区别
1、用法不同：typedef 用来定义一种数据类型的别名，增强程序的可读性；define 主要用来定义常量，以及书写复杂使用频繁的宏。
2、执行时间不同：typedef 是编译过程的一部分，有类型检查的功能；define 是宏定义，是预编译的部分，其发生在编译之前，只是简单的进行字符串的替换，不进行类型检查。
3、作用域不同：typedef 有作用域限定；define 不受作用域约束，只要是在 define 声明后的引用都是正确的。
4、对指针的操作不同：typedef 和 define 定义的指针时有很大的区别。

```
#define PINT int*
typedef int* Pint;
int a = 3;
int b = 5;
const Pint p1 = &a;  //相当于int* const p1，p1不可以更改但其指向的内容可改
*p1 = 1;  //指向的内容被修改，正确
p1 = &b;  //错误
const PINT p2 = &a;  //相当于const int *p2，p2可以被修改但其指向的内容不可修改
p2 = &b;  //正确
*p2 = 1;  //错误
```

## 三、sizeof求类的大小
空类class A {}；
加构造函数,析构函数；
加一个static int成员；
把析构函数标记为虚函数；
sizeof(A)是多少?

注意要点：
1、C++中规定只要是一个独立的对象内存大小必须是非0的，所以空类大小是1。
2、静态数据程序不计算在类对象大小中，为所有的类对象所共有，定义在内存全局区。
3、类大小的计算遵循结构体的对齐原则。
4、类的大小与普通数据成员有关，与成员函数和静态成员无关。即普通成员函数，静态成员函数，静态数据成员，静态常量数据成员均对类的大小无影响。
5、虚函数对类的大小有影响，是因为虚函数表指针带来的影响。
6、虚继承对类的大小有影响，是因为虚基表指针带来的影响。

## 四、sizeof和strlen的区别
主要区别：
1、sizeof() 是一个运算符，而 strlen() 是一个函数。
2、sizeof() 计算的是变量或类型所占用的内存字节数，而 strlen() 计算的是字符串中字符的个数。
3、sizeof() 可以用于任何类型的数据，而 strlen() 只能用于以空字符 '\0' 结尾的字符串。
4、sizeof() 计算字符串的长度，包含末尾的 '\0'，strlen() 计算字符串的长度，不包含字符串末尾的 '\0'。
5、sizeof() 是一个运算符而不是函数，用于计算一个类型或变量所占用的内存字节数；可以用它来获取任何类型的数据的字节数，包括基本数据类型、数组、结构体、共用体等等。
```
char aa[10];strlen(aa);          //结果是不定的   
sizeof(aa);      //结果是10
char aa[10]={‘\0’};strlen(aa);  //结果为0        
sizeof(aa);      //结果是10
char aa[]=”CPP”;strlen(aa);     //结果为3             
sizeof(aa);      //结果是4
char*aa=”0123456789”;   //字符串常量的情况
sizeof(aa);        //结果为4，指针的长度
sizeof(*aa);       //结果为1，第一个字符的空间
strlen(aa);         //结果为0，该字符串的长度

char aaa[]={"CPPCPP"};
int a,b;
fun(aaa,a,b);
void fun(char aaa[],int&a,int&b)
{
  a=strlen(aaa);
  b=sizeof(aaa);
}
//得到的a=6，b=4.在函数内部，虽然aaa转化成指针，但是strlen还是测试aaa开始直到’\0’为止的字符串的长度，而sizeof则是测指针的长度
```
## 五、字节对齐
1、意义：结构体以及类成员对齐，目的就是减少cpu读取的次数，提高效率。
2、结构体成员对齐的规则：
1）结构体大小等于结构体内最大成员大小的整数倍；
2）结构体内的成员的首地址相对于结构体首地址的偏移量，是其类型大小的整数倍，比如说double型成员相对于结构体的首地址的偏移量应该是8的整数倍；
3）为了满足规则1和规则2编译器会在结构体成员之后进行字节填充。
```
struct A{
  char a;
  double b;
  int c;
};
struct B{
  double a;
  char b;
  int c;
};
sizeof(A):24
sizeof(B):16
```
## 六、封装、继承、多态
1、封装
定义：封装就是将抽象的数据和行为相结合，形成一个有机的整体类，其中数据和函数都是类的成员，目的在于将对象的使用者和设计者分开，以提高软件的可维护性和可修改性。
特性：1) 结合性，即是将属性和方法结合；2）信息隐蔽性，利用接口机制隐蔽内部实现细节，只留下接口给外界调用，便于权限控制；3）实现代码重用。

2、继承
1）继承就是新类从已有类那里得到已有的特性，类的派生指的是从已有类产生新类的过程，原有的类成为基类或父类，产生的新类称为派生类或子类。
2）继承可以扩展已存在的代码，目的也是为了代码重用。
3）继承增加了类的耦合性。
4）继承是多态的前提。

3、多态
1）多态性可以简单地概括为“一个接口，多种方法”，类和继承的存在就是为了实现多态。
2）它是面向对象编程领域的核心概念，程序在运行时才决定调用的函数，比如函数重载、运算符重载、虚函数等都是为了多态而存在。
3）多态有两种形式的多态，一种是静态多态，一种是动态多态。
静态多态通过模板和重载实现；动态多态通过需函数实现。

## 七、

