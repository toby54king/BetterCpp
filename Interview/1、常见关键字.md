# C++常见关键字

## 一、static

static 是 C++ 中的关键字，用于为元素赋予特殊的特性;静态元素在程序生存期内仅在`静态存储区`中分配一次存储,一直作用到程序生存期。它主要有以下几个作用：

1、修饰普通变量: 修改变量的存储区域和生命周期，使变量存储在静态区，在main函数运行前就分配了空间，如果有初始值就用初始值初始化它，没有初始值系统会给它一个默认值。
2、修饰普通函数: 表示函数的作用范围，仅在定义该函数的文件内才能使用,在多人开发同一个项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为static。
3、修饰类的成员变量: 修饰类的成员变量使所有的类对象只保存一个该变量，而且不需要生成类对象就可以访问该类的成员变量。
4、修饰类的成员函数: 修饰类的成员函数使得不需要生成类对象就可以访问该函数，但是在static函数内不能访问非静态类成员变量。

5、静态全局变量：在全局变量前，加上关键字static，该变量就被定义成为一个静态全局变量。
该变量在全局数据区分配内存，后面的静态局部变量也是。
未经初始化的静态全局变量会被程序自动初始化一个值（自动变量的值是随机的，除非它被显式初始化）；
静态全局变量在声明它的整个文件中都是可见的，而在文件之外是不可见的。

6、静态局部变量：静态局部变量保存在全局数据区，而不是保存在栈中，每次的值保持到下一次调用，直到下次赋新值。
该变量在全局数据区分配内存；静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；
静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化；它始终驻留在全局数据区，直到程序运行结束；
但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束。

## 二、const

const 是 constant的缩写，是不变的，不易改变的意思；在 C++ 中是用来修饰内置类型变量、自定义对象、成员函数、返回值、函数参数；编程中确定有某个值保持不变，就应该明确使用const。
1、const修饰普通类型的变量。
2、const修饰指针变量。
3、const用于参数传递和函数返回值。
4、const修饰类成员函数。

## 三、inline
场景：当频繁调用小函数时，为了节省函数调用的开销，可以用内联函数。
注意：inline修饰函数的时候要加上函数体，不然没有用。
优点：执行的速度快；调用时候会检查参数类型，比较安全；可以用来修饰保护成员和私有成员；类中定义的函数不管加不加inline都会是内联函数。
缺点：以函数复制为代价，如果过多使用，会消耗内存；如果函数体内有循环，那么执行函数代码的时间比调用要开销大；
是否内联，程序员不可控，inline只是对编译器的建议，是否内联取决于编译器。

## 四、volatite
1、volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据，而且读取的数据立刻被保存。

2、多线程并发访问共享变量时，一个线程改变了变量的值，如何让改变后的值对其它线程可见，这就要用到volatile：
中断服务程序中修改的，供其它程序检测的变量需要加关键字volatile；多任务环境下各任务间共享的标志应该加volatile；存储器映射的硬件寄存器要加volatile说明，因为每次对它的读写都可能有不同的意义。

## 五、sizeof
1、sizeof是C++的一个关键字，它是编译时的运算符，不是函数，用于判断变量或数据类型的字节大小。
2、sizeof 运算符可用于获取类、结构、共用体和其他用户自定义数据类型的大小。
3、使用语法：sizeof (data type)

## 六、extern C
1、目的：为了解决函数名字匹配保证兼容性。
2、原因：C++支持函数重载，C语言不支持函数重载，C语言中函数编译后得到的汇编代码中函数名与原函数名基本相同，如func()编译后成为_func，重载函数经过编译后得到函数名并不是原来的函数名，而是函数与参数类型的结合，因此两者函数调用的方式不一样。为了C++中能够调用C中的代码，使用extern C来表明对于包括函数采用C语言的方式调用，而不采用C++的方式调用。
3、extern是C/C++语言中表明函数和全局变量作用范围（可见性）的关键字，该关键字告诉编译器，其声明的函数和变量可以在本模块或其它模块中使用。通常，在模块的头文件中对本模块提供给其它模块引用的函数和全局变量以关键字extern声明。
4、例如，如果模块B欲引用该模块A中定义的全局变量和函数时只需包含模块A的头文件即可。这样，模块B中调用模块A中的函数时，在编译阶段，模块B虽然找不到该函数，但是并不会报错；它会在链接阶段中从模块A编译生成的目标代码中找到此函数extern “C”是链接接申明(linkage declaration),被extern “C”修饰的变量和函数是按照C语言方式编译和链接的。

## 七、struct和class
1、struct关键字继承自C语言，class是C++独有。
2、在C++中两者最主要区别在于声明类时的默认权限不同，struct默认的权限是public，class的默认权限是private。
3、在C++中class还可以用于声明模板类型，而struct不能。

## 八、new/delete和malloc/free
1、new/delete是C++中的运算符，malloc/free是C标准库中提供的函数，它们用于动态申请内存和释放内存的组合。
2、区别：
1）new/delete是C++的运算符，malloc/free是C/C++语言的标准库函数。
2）new能够自动分配空间大小；malloc需要指定分配内存的大小。两者分配的内存空间都是连续的，如果空间不够，会分配失败。（这里内存连续指虚拟内存连续，物理内存不一定连续）。
3）对于用户自定义的对象而言，用maloc/free无法满足动态管理对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。因此C++需要一个能对对象完成动态内存分配和初始化工作的运算符new和一个能对对象完成清理与释放内存工作的运算符delete。
4）内存初始化和清空的区别：new操作会调用对象的构造函数初始化内存区域，但malloc只负责申请内存不会初始化；delete操作会调用对象的析构函数并释放空间，而free只负责释放空间，两者在释放空间时，默认情况下不会清空原有内容，这就是新内存中值为随机数的原因。

## 九、.const和#define
变量定义时，大多数情况下const相对于#define来说有着更优的表现效果。原因如下：
1、const是用于定义一个有类型的只读常变量，而#define是宏定义，是在编译期间对定义的变量进行直接文本替换，不做类型检查。
2、const对数据进行类型检查，#define不进行类型检查。
3、某些编译器支持对const对象进行调试，所有编译器都不支持对#define进行调试。
4、const变量存放在内存的静态数据区域，在程序运行期间const变量只有一个拷贝，而#define修饰的变量会在每处都进行展开，拥有多个拷贝，浪费内存。
5、const除了可以修饰常变量外，还可以用于修饰指针、函数形参等，修饰功能更强大。
6、#define可以用来定义宏函数，而const不行。
